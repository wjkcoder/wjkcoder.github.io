{"posts":[{"fileName":"springboot-run","abstract":"","description":" 创建SpringApplication SpringApplication#run SpringApplicationRunListeners实例 SpringApplicationRunListeners实例开启监听 prepare环...","title":"SpringBoot Run","tags":[{"index":-1,"name":"SpringBoot","slug":"JZ_dCeGSA","used":true,"link":"https://wjkcoder.github.io/tag/JZ_dCeGSA/"},{"index":3,"name":"Source Code Analysis","slug":"C5tzCiKHJ","used":true,"link":"https://wjkcoder.github.io/tag/C5tzCiKHJ/"}],"feature":"https://wjkcoder.github.io/post-images/springboot-run.jpeg","link":"https://wjkcoder.github.io/post/springboot-run/","stats":{"text":"6 min read","time":304000,"words":1058,"minutes":6},"isTop":true,"toc":"<ul class=\"markdownIt-TOC\">\n<li><a href=\"#%E5%88%9B%E5%BB%BAspringapplication\">创建SpringApplication</a></li>\n<li><a href=\"#springapplicationrun\">SpringApplication#run</a>\n<ul>\n<li><a href=\"#springapplicationrunlisteners%E5%AE%9E%E4%BE%8B\">SpringApplicationRunListeners实例</a></li>\n<li><a href=\"#springapplicationrunlisteners%E5%AE%9E%E4%BE%8B%E5%BC%80%E5%90%AF%E7%9B%91%E5%90%AC\">SpringApplicationRunListeners实例开启监听</a></li>\n<li><a href=\"#prepare%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F\">prepare环境变量</a></li>\n<li><a href=\"#%E5%88%9B%E5%BB%BAapplicationcontext\">创建ApplicationContext</a>\n<ul>\n<li><a href=\"#%E5%88%9B%E5%BB%BA%E6%B3%A8%E8%A7%A3beandefinitionreader\">创建注解beanDefinitionReader</a></li>\n<li><a href=\"#%E5%88%9B%E5%BB%BAclasspathbeandefinitionscanner\">创建ClassPathBeanDefinitionScanner</a>\n<ul>\n<li><a href=\"#%E6%B3%A8%E5%86%8C%E9%BB%98%E8%AE%A4filter\">注册默认filter</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#springapplicationpreparecontext\">SpringApplication#prepareContext</a>\n<ul>\n<li><a href=\"#abstractapplicationcontextrefresh\">AbstractApplicationContext#refresh</a>\n<ul>\n<li><a href=\"#abstractapplicationcontextpreparerefresh\">AbstractApplicationContext#prepareRefresh</a></li>\n<li><a href=\"#abstractapplicationcontextpreparebeanfactory\">AbstractApplicationContext#prepareBeanFactory</a>\n<ul>\n<li><a href=\"#%E6%B7%BB%E5%8A%A0bpp-applicationcontextawareprocessor\">添加BPP ApplicationContextAwareProcessor</a></li>\n<li><a href=\"#%E6%B7%BB%E5%8A%A0ignore%E6%8E%A5%E5%8F%A3\">添加ignore接口</a></li>\n<li><a href=\"#%E6%B3%A8%E5%86%8Cdependency\">注册dependency</a></li>\n<li><a href=\"#%E6%B7%BB%E5%8A%A0bpp-applicationlistenerdetector\">添加BPP ApplicationListenerDetector</a></li>\n<li><a href=\"#%E6%B3%A8%E5%86%8C%E9%BB%98%E8%AE%A4%E7%8E%AF%E5%A2%83bean%E5%88%B0singleton\">注册默认环境bean到singleton</a></li>\n</ul>\n</li>\n<li><a href=\"#postprocessbeanfactory\">postProcessBeanFactory</a></li>\n<li><a href=\"#invokebeanfactorypostprocessors\">invokeBeanFactoryPostProcessors</a>\n<ul>\n<li><a href=\"#invokebeandefinitionregistrypostprocessors\">invokeBeanDefinitionRegistryPostProcessors</a>\n<ul>\n<li><a href=\"#configurationclasspostprocessorprocessconfigbeandefinitions\">ConfigurationClassPostProcessor#processConfigBeanDefinitions</a></li>\n<li><a href=\"#configurationclassparserparse\">ConfigurationClassParser#parse</a></li>\n</ul>\n</li>\n<li><a href=\"#invokebeanfactorypostprocessors-2\">invokeBeanFactoryPostProcessors</a></li>\n<li><a href=\"#%E5%88%86%E6%89%B9%E6%AC%A1%E6%89%A7%E8%A1%8Cbeanfactoryprocessor\">分批次执行BeanFactoryProcessor</a></li>\n</ul>\n</li>\n<li><a href=\"#registerbeanpostprocessors\">registerBeanPostProcessors</a></li>\n<li><a href=\"#initmessagesource\">initMessageSource</a></li>\n<li><a href=\"#initapplicationeventmulticaster\">initApplicationEventMulticaster</a></li>\n<li><a href=\"#onfresh\">onfresh</a></li>\n<li><a href=\"#registerlisteners\">registerListeners</a></li>\n<li><a href=\"#finishbeanfactoryinitialization\">finishBeanFactoryInitialization</a>\n<ul>\n<li><a href=\"#%E5%88%9D%E5%A7%8B%E5%8C%96bean\">初始化bean</a>\n<ul>\n<li><a href=\"#1%E5%88%A4%E6%96%AD%E4%B8%8D%E6%98%AFabstract%E6%98%AF%E5%8D%95%E4%BE%8B%E9%9D%9E%E6%87%92%E5%8A%A0%E8%BD%BD%E6%89%A7%E8%A1%8Cgetbean\">1.判断不是abstract，是单例非懒加载，执行getBean</a></li>\n<li><a href=\"#2abstractbeanfactorydogetbean\">2.AbstractBeanFactory#doGetbean</a></li>\n</ul>\n</li>\n<li><a href=\"#%E6%89%A7%E8%A1%8Cbean%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86\">执行bean后置处理</a></li>\n</ul>\n</li>\n<li><a href=\"#finishrefresh\">finishRefresh</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#springapplicationafterrefresh\">SpringApplication#afterRefresh</a></li>\n<li><a href=\"#listeners%E5%93%8D%E5%BA%94%E6%89%A7%E8%A1%8Cstart%E4%BA%8B%E4%BB%B6\">listeners响应执行start事件</a></li>\n</ul>\n</li>\n</ul>\n","date":"2021-03-05 17:19:46","dateFormat":"2021-03-05"},{"fileName":"netty-core-channel-readandwrite","abstract":"<ul>\n<li><a href=\"#niosocketchannel-read%E5%AE%9E%E7%8E%B0\">NioSocketChannel read实现</a>\n<ul>\n<li><a href=\"#abstractniobytechannelread\">AbstractNioByteChannel#read</a></li>\n<li><a href=\"#niobyteunsaferead\">NioByteUnsafe#read</a></li>\n<li><a href=\"#niosocketchanneldoreadbytes\">NioSocketChannel#doReadBytes</a>\n<ul>\n<li><a href=\"#abstractbytebufwritebytes\">AbstractByteBuf#writeBytes</a></li>\n<li><a href=\"#pooledbytebufsetbytes\">PooledByteBuf#setBytes</a></li>\n</ul>\n</li>\n<li><a href=\"#jdk-socketchannelimplread\">JDK SocketChannelImpl#read</a>\n<ul>\n<li><a href=\"#ioutilread\">IOUtil#read</a></li>\n<li><a href=\"#ioutilreadintonativebuffer\">IOUtil#readIntoNativeBuffer</a></li>\n<li><a href=\"#socketdispatcherread\">SocketDispatcher#read</a>\n<ul>\n<li><a href=\"#filedispatcherimplread0\">FileDispatcherImpl#read0</a></li>\n<li><a href=\"#jni-read0\">JNI read0</a></li>\n<li><a href=\"#ioh--read\">io.h  #read</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#niosocketchannel-write%E5%AE%9E%E7%8E%B0\">NioSocketChannel Write实现</a>\n<ul>\n<li><a href=\"#abstractchannelhandlercontextwriteandflush\">AbstractChannelHandlerContext#writeAndFlush</a></li>\n<li><a href=\"#invokewrite0\">invokeWrite0</a>\n<ul>\n<li><a href=\"#unsafewrite\">unsafe#write</a></li>\n</ul>\n</li>\n<li><a href=\"#invokeflush0\">invokeFlush0</a>\n<ul>\n<li><a href=\"#unsafeflush\">unsafe#flush</a></li>\n<li><a href=\"#flush0\">flush0</a></li>\n</ul>\n</li>\n<li><a href=\"#niosocketchanneldowrite\">NioSocketChannel#doWrite</a></li>\n<li><a href=\"#jdk-socketchannelwirte\">JDK SocketChannel#wirte</a>\n<ul>\n<li><a href=\"#ioutilwrite\">IOUtil#write</a></li>\n<li><a href=\"#ioutilwritefromnativebuffer\">IOUtil#writeFromNativeBuffer</a></li>\n<li><a href=\"#socketdispatcherwrite\">SocketDispatcher#write</a>\n<ul>\n<li><a href=\"#filedispatcherwrite0\">FileDispatcher#write0</a></li>\n<li><a href=\"#jni-write0\">JNI write0</a></li>\n<li><a href=\"#ioh-write\">io.h #write</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>零拷贝是Netty自身实现的吗？<br>\n至少在读/写操作时，零拷贝并不是Netty去实现的，而是jdk的NIO本身提供的api</p>\n<h2 id=\"niosocketchannel-read实现\">NioSocketChannel read实现</h2>\n<p>起点在NioEventLoop的run中的processSelectedKeys，调用unsafe的read</p>\n<h3 id=\"abstractniobytechannelread\">AbstractNioByteChannel#read</h3>\n<p>这里和NSSC的AbstractNioMessageChannel区分开，这里的byte是专门处理字节流的, 具体参与处理的其内部实现类NioByteUnsafe</p>\n<h3 id=\"niobyteunsaferead\">NioByteUnsafe#read</h3>\n<ul>\n<li>1.分配一块ByteBuffer</li>\n<li>2.把channel的字节流读到buffer</li>\n<li>3.处理完之后的buffer作为参数处理之后的pipline.fireChannelRead这里跟io读写相关的只发生在2，fireChannelRead可以看作是业务层面的处理，因为底层的字节流已经拿到了。下面只讨论2</li>\n</ul>\n<pre><code class=\"language-java\">protected class NioByteUnsafe extends AbstractNioUnsafe {\n\n    @Override\n    public final void read() {\n        final ChannelConfig config = config();\n        if (shouldBreakReadReady(config)) {\n            clearReadPending();\n            return;\n        }\n        final ChannelPipeline pipeline = pipeline();\n        final ByteBufAllocator allocator = config.getAllocator();\n        final RecvByteBufAllocator.Handle allocHandle = recvBufAllocHandle();\n        allocHandle.reset(config);\n\n        ByteBuf byteBuf = null;\n        boolean close = false;\n        try {\n            do {\n                byteBuf = allocHandle.allocate(allocator);\n                allocHandle.lastBytesRead(doReadBytes(byteBuf));\n                if (allocHandle.lastBytesRead() &lt;= 0) {\n                    // nothing was read. release the buffer.\n                    byteBuf.release();\n                    byteBuf = null;\n                    close = allocHandle.lastBytesRead() &lt; 0;\n                    if (close) {\n                        // There is nothing left to read as we received an EOF.\n                        readPending = false;\n                    }\n                    break;\n                }\n\n                allocHandle.incMessagesRead(1);\n                readPending = false;\n                pipeline.fireChannelRead(byteBuf);\n                byteBuf = null;\n            } while (allocHandle.continueReading());\n\n            allocHandle.readComplete();\n            pipeline.fireChannelReadComplete();\n    }\n}\n\n</code></pre>\n<h3 id=\"niosocketchanneldoreadbytes\">NioSocketChannel#doReadBytes</h3>\n<pre><code class=\"language-java\">protected int doReadBytes(ByteBuf byteBuf) throws Exception {\n    final RecvByteBufAllocator.Handle allocHandle = unsafe().recvBufAllocHandle();\n    allocHandle.attemptedBytesRead(byteBuf.writableBytes());\n    return byteBuf.writeBytes(javaChannel(), allocHandle.attemptedBytesRead());\n}\n\n</code></pre>\n<h4 id=\"abstractbytebufwritebytes\">AbstractByteBuf#writeBytes</h4>\n<pre><code class=\"language-java\">public int writeBytes(ScatteringByteChannel in, int length) throws IOException {\n    ensureWritable(length);\n    int writtenBytes = setBytes(writerIndex, in, length);\n    if (writtenBytes &gt; 0) {\n        writerIndex += writtenBytes;\n    }\n    return writtenBytes;\n}\n\n</code></pre>\n<h4 id=\"pooledbytebufsetbytes\">PooledByteBuf#setBytes</h4>\n<pre><code class=\"language-java\">public final int setBytes(int index, ScatteringByteChannel in, int length) throws IOException {\n    try {\n        return in.read(internalNioBuffer(index, length));\n    } catch (ClosedChannelException ignored) {\n        return -1;\n    }\n}\n\n</code></pre>\n<h3 id=\"jdk-socketchannelimplread\">JDK SocketChannelImpl#read</h3>\n<p>核心部分</p>\n<ul>\n<li>1.或者read同步锁</li>\n<li>2.while执行IOUtil read，从fd读字节流到buffer</li>\n</ul>\n<pre><code class=\"language-java\">public int read(ByteBuffer var1) throws IOException {\n    if (var1 == null) {\n        throw new NullPointerException();\n    } else {\n        synchronized(this.readLock) {\n            if (!this.ensureReadOpen()) {\n                return -1;\n            } else {\n                int var3 = 0;\n                boolean var20 = false;\n\n                byte var10000;\n                byte var5;\n                label360: {\n                    int var4;\n                    try {\n                        var20 = true;\n                        this.begin();\n                        synchronized(this.stateLock) {\n                            if (!this.isOpen()) {\n                                var5 = 0;\n                                var20 = false;\n                                break label360;\n                            }\n\n                            this.readerThread = NativeThread.current();\n                        }\n\n                        while(true) {\n                            var3 = IOUtil.read(this.fd, var1, -1L, nd);\n                            if (var3 != -3 || !this.isOpen()) {\n                                var4 = IOStatus.normalize(var3);\n                                var20 = false;\n                                break;\n                            }\n            }\n        }\n    }\n}\n\n</code></pre>\n<h4 id=\"ioutilread\">IOUtil#read</h4>\n<ul>\n<li>1.区分buffer的类型，是否是直接内存/堆外内存</li>\n<li>2.若是直接内存，直接执行堆外内存的逻辑；</li>\n<li>3.若是heap，需要先将heap转化为堆外内存，再执行2的逻辑</li>\n</ul>\n<p>之所以认为不是Netty在读写时实现了零拷贝技术，是因为jdk本身就提供了堆内存和直接内存的实现，Netty只是在此基础上默认使用了DirectBuffer实例而已，<br>\n若自己用NIO的api来写read操作，在指定buffer的时候使用堆外内存也可以达到相同的效果；</p>\n<pre><code class=\"language-java\">static int read(FileDescriptor var0, ByteBuffer var1, long var2, NativeDispatcher var4) throws IOException {\n    if (var1.isReadOnly()) {\n        throw new IllegalArgumentException(&quot;Read-only buffer&quot;);\n    } else if (var1 instanceof DirectBuffer) {\n        return readIntoNativeBuffer(var0, var1, var2, var4);\n    } else {\n        //这里要去分配一块直接内存\n        ByteBuffer var5 = Util.getTemporaryDirectBuffer(var1.remaining());\n\n        int var7;\n        try {\n            int var6 = readIntoNativeBuffer(var0, var5, var2, var4);\n            var5.flip();\n            if (var6 &gt; 0) {\n                var1.put(var5);\n            }\n\n            var7 = var6;\n        } finally {\n            Util.offerFirstTemporaryDirectBuffer(var5);\n        }\n\n        return var7;\n    }\n}\n\n</code></pre>\n<h4 id=\"ioutilreadintonativebuffer\">IOUtil#readIntoNativeBuffer</h4>\n<p>计算剩余要读的字节，使用dispatcher去读取</p>\n<pre><code class=\"language-java\">private static int readIntoNativeBuffer(FileDescriptor var0, ByteBuffer var1, long var2, NativeDispatcher var4) throws IOException {\n    int var5 = var1.position();\n    int var6 = var1.limit();\n\n    assert var5 &lt;= var6;\n\n    int var7 = var5 &lt;= var6 ? var6 - var5 : 0;\n    if (var7 == 0) {\n        return 0;\n    } else {\n        boolean var8 = false;\n        int var9;\n        if (var2 != -1L) {\n            var9 = var4.pread(var0, ((DirectBuffer)var1).address() + (long)var5, var7, var2);\n        } else {\n            var9 = var4.read(var0, ((DirectBuffer)var1).address() + (long)var5, var7);\n        }\n\n        if (var9 &gt; 0) {\n            var1.position(var5 + var9);\n        }\n\n        return var9;\n    }\n}\n\n</code></pre>\n<h4 id=\"socketdispatcherread\">SocketDispatcher#read</h4>\n<h5 id=\"filedispatcherimplread0\">FileDispatcherImpl#read0</h5>\n<pre><code class=\"language-java\">FileDispatcherImpl#read0\n</code></pre>\n<h5 id=\"jni-read0\">JNI read0</h5>\n<pre><code class=\"language-cpp\">JNIEXPORT jint JNICALL\nJava_sun_nio_ch_FileDispatcherImpl_read0(JNIEnv *env, jclass clazz,\n                             jobject fdo, jlong address, jint len)\n{\n    jint fd = fdval(env, fdo);\n    void *buf = (void *)jlong_to_ptr(address);\n\n    return convertReturnVal(env, read(fd, buf, len), JNI_TRUE);\n}\n\n</code></pre>\n<h5 id=\"ioh-read\">io.h  #read</h5>\n<p>从fd文件描述符所在文件，读size个字节到buf所在的内存地址</p>\n<pre><code class=\"language-cpp\">static inline int read(int fd, void* buf, unsigned int size) { return _read(fd, buf, size); }\n</code></pre>\n<h2 id=\"niosocketchannel-write实现\">NioSocketChannel Write实现</h2>\n<p>写的起点是ctx.writeAndFlush</p>\n<h3 id=\"abstractchannelhandlercontextwriteandflush\">AbstractChannelHandlerContext#writeAndFlush</h3>\n<pre><code class=\"language-java\">public ChannelFuture writeAndFlush(Object msg) {\n    return writeAndFlush(msg, newPromise());\n}\npublic ChannelFuture writeAndFlush(Object msg, ChannelPromise promise) {\n    write(msg, true, promise);\n    return promise;\n}\nprivate void write(Object msg, boolean flush, ChannelPromise promise) {\n    ObjectUtil.checkNotNull(msg, &quot;msg&quot;);\n    try {\n        if (isNotValidPromise(promise, true)) {\n            ReferenceCountUtil.release(msg);\n            // cancelled\n            return;\n        }\n    } catch (RuntimeException e) {\n        ReferenceCountUtil.release(msg);\n        throw e;\n    }\n\n    final AbstractChannelHandlerContext next = findContextOutbound(flush ?\n            (MASK_WRITE | MASK_FLUSH) : MASK_WRITE);\n    final Object m = pipeline.touch(msg, next);\n    EventExecutor executor = next.executor();\n    if (executor.inEventLoop()) {\n        if (flush) {\n            next.invokeWriteAndFlush(m, promise);\n        } else {\n            next.invokeWrite(m, promise);\n        }\n    } else {\n        final WriteTask task = WriteTask.newInstance(next, m, promise, flush);\n        if (!safeExecute(executor, task, promise, m, !flush)) {\n            // We failed to submit the WriteTask. We need to cancel it so we decrement the pending bytes\n            // and put it back in the Recycler for re-use later.\n            //\n            // See https://github.com/netty/netty/issues/8343.\n            task.cancel();\n        }\n    }\n}\nvoid invokeWriteAndFlush(Object msg, ChannelPromise promise) {\n    if (invokeHandler()) {\n        invokeWrite0(msg, promise);\n        invokeFlush0();\n    } else {\n        writeAndFlush(msg, promise);\n    }\n}\n\n</code></pre>\n<p><strong>channel的字节流不是立刻发送的，分成了两个动作，一个缓存和组合message，另一个flush才是真正的发送；</strong></p>\n<h3 id=\"invokewrite0\">invokeWrite0</h3>\n<h4 id=\"unsafewrite\">unsafe#write</h4>\n<ul>\n<li>1.有一个outboundBuffer，代表最后真正要发送的字节</li>\n<li>2.过滤msg，通过之后的msg才会被加入到out中</li>\n<li>3.添加msg</li>\n</ul>\n<pre><code class=\"language-java\">public final void write(Object msg, ChannelPromise promise) {\n    assertEventLoop();\n\n    ChannelOutboundBuffer outboundBuffer = this.outboundBuffer;\n    if (outboundBuffer == null) {\n        try {\n            // release message now to prevent resource-leak\n            ReferenceCountUtil.release(msg);\n        } finally {\n            // If the outboundBuffer is null we know the channel was closed and so\n            // need to fail the future right away. If it is not null the handling of the rest\n            // will be done in flush0()\n            // See https://github.com/netty/netty/issues/2362\n            safeSetFailure(promise,\n                    newClosedChannelException(initialCloseCause, &quot;write(Object, ChannelPromise)&quot;));\n        }\n        return;\n    }\n\n    int size;\n    try {\n        msg = filterOutboundMessage(msg);\n        size = pipeline.estimatorHandle().size(msg);\n        if (size &lt; 0) {\n            size = 0;\n        }\n    } catch (Throwable t) {\n        try {\n            ReferenceCountUtil.release(msg);\n        } finally {\n            safeSetFailure(promise, t);\n        }\n        return;\n    }\n\n    outboundBuffer.addMessage(msg, size, promise);\n}\n\n</code></pre>\n<h3 id=\"invokeflush0\">invokeFlush0</h3>\n<h4 id=\"unsafeflush\">unsafe#flush</h4>\n<ul>\n<li>1.拿到write之后的outboundBuffer</li>\n<li>2.确认每一个promise</li>\n<li>3.执行flush0</li>\n</ul>\n<pre><code class=\"language-java\">public final void flush() {\n    assertEventLoop();\n\n    ChannelOutboundBuffer outboundBuffer = this.outboundBuffer;\n    if (outboundBuffer == null) {\n        return;\n    }\n\n    outboundBuffer.addFlush();\n    flush0();\n}\npublic void addFlush() {\n    // There is no need to process all entries if there was already a flush before and no new messages\n    // where added in the meantime.\n    //\n    // See https://github.com/netty/netty/issues/2577\n    Entry entry = unflushedEntry;\n    if (entry != null) {\n        if (flushedEntry == null) {\n            // there is no flushedEntry yet, so start with the entry\n            flushedEntry = entry;\n        }\n        do {\n            flushed ++;\n            if (!entry.promise.setUncancellable()) {\n                // Was cancelled so make sure we free up memory and notify about the freed bytes\n                int pending = entry.cancel();\n                decrementPendingOutboundBytes(pending, false, true);\n            }\n            entry = entry.next;\n        } while (entry != null);\n\n        // All flushed so reset unflushedEntry\n        unflushedEntry = null;\n    }\n}\n\n</code></pre>\n<h4 id=\"flush0\">flush0</h4>\n<pre><code class=\"language-java\">protected void flush0() {\n    if (inFlush0) {\n        // Avoid re-entrance\n        return;\n    }\n\n    final ChannelOutboundBuffer outboundBuffer = this.outboundBuffer;\n    if (outboundBuffer == null || outboundBuffer.isEmpty()) {\n        return;\n    }\n\n    inFlush0 = true;\n\n    // Mark all pending write requests as failure if the channel is inactive.\n    if (!isActive()) {\n        try {\n            // Check if we need to generate the exception at all.\n            if (!outboundBuffer.isEmpty()) {\n                if (isOpen()) {\n                    outboundBuffer.failFlushed(new NotYetConnectedException(), true);\n                } else {\n                    // Do not trigger channelWritabilityChanged because the channel is closed already.\n                    outboundBuffer.failFlushed(newClosedChannelException(initialCloseCause, &quot;flush0()&quot;), false);\n                }\n            }\n        } finally {\n            inFlush0 = false;\n        }\n        return;\n    }\n\n    try {\n        doWrite(outboundBuffer);\n    } catch (Throwable t) {\n        handleWriteError(t);\n    } finally {\n        inFlush0 = false;\n    }\n}\n\n</code></pre>\n<h3 id=\"niosocketchanneldowrite\">NioSocketChannel#doWrite</h3>\n<ul>\n<li>1.获取nio的channel</li>\n<li>2.获取要处理的buffer数组</li>\n<li>3.执行channel.write</li>\n</ul>\n<pre><code class=\"language-java\">protected void doWrite(ChannelOutboundBuffer in) throws Exception {\n    SocketChannel ch = javaChannel();\n    int writeSpinCount = config().getWriteSpinCount();\n    do {\n        if (in.isEmpty()) {\n            // All written so clear OP_WRITE\n            clearOpWrite();\n            // Directly return here so incompleteWrite(...) is not called.\n            return;\n        }\n\n        // Ensure the pending writes are made of ByteBufs only.\n        int maxBytesPerGatheringWrite = ((NioSocketChannelConfig) config).getMaxBytesPerGatheringWrite();\n        ByteBuffer[] nioBuffers = in.nioBuffers(1024, maxBytesPerGatheringWrite);\n        int nioBufferCnt = in.nioBufferCount();\n\n        // Always use nioBuffers() to workaround data-corruption.\n        // See https://github.com/netty/netty/issues/2761\n        switch (nioBufferCnt) {\n            case 0:\n                // We have something else beside ByteBuffers to write so fallback to normal writes.\n                writeSpinCount -= doWrite0(in);\n                break;\n            case 1: {\n                // Only one ByteBuf so use non-gathering write\n                // Zero length buffers are not added to nioBuffers by ChannelOutboundBuffer, so there is no need\n                // to check if the total size of all the buffers is non-zero.\n                ByteBuffer buffer = nioBuffers[0];\n                int attemptedBytes = buffer.remaining();\n                final int localWrittenBytes = ch.write(buffer);\n                if (localWrittenBytes &lt;= 0) {\n                    incompleteWrite(true);\n                    return;\n                }\n                adjustMaxBytesPerGatheringWrite(attemptedBytes, localWrittenBytes, maxBytesPerGatheringWrite);\n                in.removeBytes(localWrittenBytes);\n                --writeSpinCount;\n                break;\n            }\n            default: {\n                // Zero length buffers are not added to nioBuffers by ChannelOutboundBuffer, so there is no need\n                // to check if the total size of all the buffers is non-zero.\n                // We limit the max amount to int above so cast is safe\n                long attemptedBytes = in.nioBufferSize();\n                final long localWrittenBytes = ch.write(nioBuffers, 0, nioBufferCnt);\n                if (localWrittenBytes &lt;= 0) {\n                    incompleteWrite(true);\n                    return;\n                }\n                // Casting to int is safe because we limit the total amount of data in the nioBuffers to int above.\n                adjustMaxBytesPerGatheringWrite((int) attemptedBytes, (int) localWrittenBytes,\n                        maxBytesPerGatheringWrite);\n                in.removeBytes(localWrittenBytes);\n                --writeSpinCount;\n                break;\n            }\n        }\n    } while (writeSpinCount &gt; 0);\n\n    incompleteWrite(writeSpinCount &lt; 0);\n}\n\n</code></pre>\n<h3 id=\"jdk-socketchannelwirte\">JDK SocketChannel#wirte</h3>\n<ul>\n<li>1.获取wirte同步锁</li>\n<li>2.执行IOUtil write</li>\n</ul>\n<pre><code class=\"language-java\">public int write(ByteBuffer var1) throws IOException {\n    if (var1 == null) {\n        throw new NullPointerException();\n    } else {\n        synchronized(this.writeLock) {\n            this.ensureWriteOpen();\n            int var3 = 0;\n            boolean var20 = false;\n\n            byte var5;\n            label310: {\n                int var4;\n                try {\n                    var20 = true;\n                    this.begin();\n                    synchronized(this.stateLock) {\n                        if (!this.isOpen()) {\n                            var5 = 0;\n                            var20 = false;\n                            break label310;\n                        }\n\n                        this.writerThread = NativeThread.current();\n                    }\n\n                    do {\n                        var3 = IOUtil.write(this.fd, var1, -1L, nd);\n                    } while(var3 == -3 &amp;&amp; this.isOpen());\n\n                    var4 = IOStatus.normalize(var3);\n                    var20 = false;\n                } finally {\n                    if (var20) {\n                        this.writerCleanup();\n                        this.end(var3 &gt; 0 || var3 == -2);\n                        synchronized(this.stateLock) {\n                            if (var3 &lt;= 0 &amp;&amp; !this.isOutputOpen) {\n                                throw new AsynchronousCloseException();\n                            }\n                        }\n\n                        assert IOStatus.check(var3);\n\n                    }\n                }\n\n                this.writerCleanup();\n                this.end(var3 &gt; 0 || var3 == -2);\n                synchronized(this.stateLock) {\n                    if (var3 &lt;= 0 &amp;&amp; !this.isOutputOpen) {\n                        throw new AsynchronousCloseException();\n                    }\n                }\n\n                assert IOStatus.check(var3);\n\n                return var4;\n            }\n\n            this.writerCleanup();\n            this.end(var3 &gt; 0 || var3 == -2);\n            synchronized(this.stateLock) {\n                if (var3 &lt;= 0 &amp;&amp; !this.isOutputOpen) {\n                    throw new AsynchronousCloseException();\n                }\n            }\n\n            assert IOStatus.check(var3);\n\n            return var5;\n        }\n    }\n}\n\n</code></pre>\n<h4 id=\"ioutilwrite\">IOUtil#write</h4>\n<ul>\n<li>1.判断是否是堆外内存</li>\n<li>2.若是堆外内存，直接执行内外内存处理逻辑；</li>\n<li>3.不是堆外内存，创建一块堆外内存，把heapbuffer拷贝到堆外内存，再执行2的逻辑</li>\n</ul>\n<pre><code class=\"language-java\">static int write(FileDescriptor var0, ByteBuffer var1, long var2, NativeDispatcher var4) throws IOException {\n    if (var1 instanceof DirectBuffer) {\n        return writeFromNativeBuffer(var0, var1, var2, var4);\n    } else {\n        int var5 = var1.position();\n        int var6 = var1.limit();\n\n        assert var5 &lt;= var6;\n\n        int var7 = var5 &lt;= var6 ? var6 - var5 : 0;\n        ByteBuffer var8 = Util.getTemporaryDirectBuffer(var7);\n\n        int var10;\n        try {\n            var8.put(var1);//heap拷贝到direct\n            var8.flip();//切换读写模式\n            var1.position(var5);\n            int var9 = writeFromNativeBuffer(var0, var8, var2, var4);\n            if (var9 &gt; 0) {\n                var1.position(var5 + var9);\n            }\n\n            var10 = var9;\n        } finally {\n            Util.offerFirstTemporaryDirectBuffer(var8);\n        }\n\n        return var10;\n    }\n}\n\n</code></pre>\n<h4 id=\"ioutilwritefromnativebuffer\">IOUtil#writeFromNativeBuffer</h4>\n<ul>\n<li>1.确认要写的边界</li>\n<li>2.执行dispatcher的write</li>\n</ul>\n<pre><code class=\"language-java\">private static int writeFromNativeBuffer(FileDescriptor var0, ByteBuffer var1, long var2, NativeDispatcher var4) throws IOException {\n    int var5 = var1.position();\n    int var6 = var1.limit();\n\n    assert var5 &lt;= var6;\n\n    int var7 = var5 &lt;= var6 ? var6 - var5 : 0;\n    boolean var8 = false;\n    if (var7 == 0) {\n        return 0;\n    } else {\n        int var9;\n        if (var2 != -1L) {\n            var9 = var4.pwrite(var0, ((DirectBuffer)var1).address() + (long)var5, var7, var2);\n        } else {\n            var9 = var4.write(var0, ((DirectBuffer)var1).address() + (long)var5, var7);\n        }\n\n        if (var9 &gt; 0) {\n            var1.position(var5 + var9);\n        }\n\n        return var9;\n    }\n}\n\n</code></pre>\n<h4 id=\"socketdispatcherwrite\">SocketDispatcher#write</h4>\n<pre><code class=\"language-java\">int write(FileDescriptor var1, long var2, int var4) throws IOException {\n    return FileDispatcherImpl.write0(var1, var2, var4);\n}\n\n</code></pre>\n<h5 id=\"filedispatcherwrite0\">FileDispatcher#write0</h5>\n<pre><code class=\"language-java\">static native int write0(FileDescriptor var0, long var1, int var3) throws IOException;\n\n</code></pre>\n<h5 id=\"jni-write0\">JNI write0</h5>\n<ul>\n<li>1.获取文件描述符fd</li>\n<li>2.获取要写入的buffer地址</li>\n</ul>\n<pre><code class=\"language-cpp\">JNIEXPORT jint JNICALL\nJava_sun_nio_ch_FileDispatcherImpl_write0(JNIEnv *env, jclass clazz,\n                              jobject fdo, jlong address, jint len)\n{\n    jint fd = fdval(env, fdo);\n    void *buf = (void *)jlong_to_ptr(address);\n\n    return convertReturnVal(env, write(fd, buf, len), JNI_FALSE);\n}\n\n</code></pre>\n<h5 id=\"ioh-write\">io.h #write</h5>\n<p>从buf往fd文件描述符打开的文件写入size个字节</p>\n<pre><code class=\"language-cpp\">static inline int write(int fd, const void* buf, unsigned int size) { return _write(fd, buf, size); }\n\n</code></pre>\n","description":" NioSocketChannel read实现 AbstractNioByteChannel#read NioByteUnsafe#read NioSocketChannel#doReadBytes AbstractByteBuf#w...","title":"Netty Core Channel Read&Write","tags":[{"index":3,"name":"Source Code Analysis","slug":"C5tzCiKHJ","used":true,"link":"https://wjkcoder.github.io/tag/C5tzCiKHJ/"},{"index":-1,"name":"Netty","slug":"t2_-QPGel","used":true,"link":"https://wjkcoder.github.io/tag/t2_-QPGel/"}],"feature":"https://wjkcoder.github.io/post-images/netty-core-channel-readandwrite.jpeg","link":"https://wjkcoder.github.io/post/netty-core-channel-readandwrite/","stats":{"text":"14 min read","time":784000,"words":2355,"minutes":14},"isTop":true,"toc":"<ul class=\"markdownIt-TOC\">\n<li>\n<ul>\n<li><a href=\"#niosocketchannel-read%E5%AE%9E%E7%8E%B0\">NioSocketChannel read实现</a>\n<ul>\n<li><a href=\"#abstractniobytechannelread\">AbstractNioByteChannel#read</a></li>\n<li><a href=\"#niobyteunsaferead\">NioByteUnsafe#read</a></li>\n<li><a href=\"#niosocketchanneldoreadbytes\">NioSocketChannel#doReadBytes</a>\n<ul>\n<li><a href=\"#abstractbytebufwritebytes\">AbstractByteBuf#writeBytes</a></li>\n<li><a href=\"#pooledbytebufsetbytes\">PooledByteBuf#setBytes</a></li>\n</ul>\n</li>\n<li><a href=\"#jdk-socketchannelimplread\">JDK SocketChannelImpl#read</a>\n<ul>\n<li><a href=\"#ioutilread\">IOUtil#read</a></li>\n<li><a href=\"#ioutilreadintonativebuffer\">IOUtil#readIntoNativeBuffer</a></li>\n<li><a href=\"#socketdispatcherread\">SocketDispatcher#read</a>\n<ul>\n<li><a href=\"#filedispatcherimplread0\">FileDispatcherImpl#read0</a></li>\n<li><a href=\"#jni-read0\">JNI read0</a></li>\n<li><a href=\"#ioh-read\">io.h  #read</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#niosocketchannel-write%E5%AE%9E%E7%8E%B0\">NioSocketChannel Write实现</a>\n<ul>\n<li><a href=\"#abstractchannelhandlercontextwriteandflush\">AbstractChannelHandlerContext#writeAndFlush</a></li>\n<li><a href=\"#invokewrite0\">invokeWrite0</a>\n<ul>\n<li><a href=\"#unsafewrite\">unsafe#write</a></li>\n</ul>\n</li>\n<li><a href=\"#invokeflush0\">invokeFlush0</a>\n<ul>\n<li><a href=\"#unsafeflush\">unsafe#flush</a></li>\n<li><a href=\"#flush0\">flush0</a></li>\n</ul>\n</li>\n<li><a href=\"#niosocketchanneldowrite\">NioSocketChannel#doWrite</a></li>\n<li><a href=\"#jdk-socketchannelwirte\">JDK SocketChannel#wirte</a>\n<ul>\n<li><a href=\"#ioutilwrite\">IOUtil#write</a></li>\n<li><a href=\"#ioutilwritefromnativebuffer\">IOUtil#writeFromNativeBuffer</a></li>\n<li><a href=\"#socketdispatcherwrite\">SocketDispatcher#write</a>\n<ul>\n<li><a href=\"#filedispatcherwrite0\">FileDispatcher#write0</a></li>\n<li><a href=\"#jni-write0\">JNI write0</a></li>\n<li><a href=\"#ioh-write\">io.h #write</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","date":"2020-03-26 14:45:38","dateFormat":"2020-03-26"},{"fileName":"netty-nioeventloop-core","abstract":"","description":" NioEventLoop 启动 NioEventLoop register NioEventLoop execute SingleThreadEventExecutor #doStartThread NioEventLoop ...","title":"Netty Core NioEventLoop","tags":[{"index":3,"name":"Source Code Analysis","slug":"C5tzCiKHJ","used":true,"link":"https://wjkcoder.github.io/tag/C5tzCiKHJ/"},{"index":-1,"name":"Netty","slug":"t2_-QPGel","used":true,"link":"https://wjkcoder.github.io/tag/t2_-QPGel/"}],"feature":"https://wjkcoder.github.io/post-images/netty-nioeventloop-core.jpeg","link":"https://wjkcoder.github.io/post/netty-nioeventloop-core/","stats":{"text":"17 min read","time":983000,"words":2939,"minutes":17},"isTop":true,"toc":"<ul class=\"markdownIt-TOC\">\n<li><a href=\"#nioeventloop-%E5%90%AF%E5%8A%A8\">NioEventLoop 启动</a>\n<ul>\n<li><a href=\"#nioeventloop-register\">NioEventLoop register</a></li>\n<li><a href=\"#nioeventloop-execute\">NioEventLoop execute</a>\n<ul>\n<li><a href=\"#singlethreadeventexecutor-dostartthread\">SingleThreadEventExecutor #doStartThread</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#nioeventloop-run%E5%A4%84%E7%90%86%E4%BA%8B%E4%BB%B6%E5%92%8C%E4%BB%BB%E5%8A%A1\">NioEventLoop #run()处理事件和任务</a>\n<ul>\n<li><a href=\"#select%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0\">Select()机制实现</a>\n<ul>\n<li><a href=\"#nioeventloop-select\">NioEventLoop select</a></li>\n<li><a href=\"#nioeventloop%E4%B8%ADwrappedselector\">NioEventLoop中wrappedSelector</a></li>\n<li><a href=\"#selectorimplselect\">SelectorImpl#select</a></li>\n<li><a href=\"#kqueueselectorimpldoselect\">KQueueSelectorImpl#doSelect</a>\n<ul>\n<li><a href=\"#kqueuewrapper-poll\">KqueueWrapper #poll</a></li>\n<li><a href=\"#jni-kevent\">JNI kevent</a></li>\n<li><a href=\"#keventh\">kevent.h</a></li>\n</ul>\n</li>\n<li><a href=\"#kqueueselectorimplupdateselectedkeys\">KQueueSelectorImpl#updateSelectedKeys</a>\n<ul>\n<li><a href=\"#kqueuearraywrappergetdescriptor\">KQueueArrayWrapper.getDescriptor</a></li>\n<li><a href=\"#thiskqueuewrappergetreventopsvar4\">this.kqueueWrapper.getReventOps(var4)</a></li>\n<li><a href=\"#%E6%9B%B4%E6%96%B0selectedkeys\">更新SelectedKeys</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#processselectedkeys-%E5%A4%84%E7%90%86%E5%93%8D%E5%BA%94%E4%BA%8B%E4%BB%B6\">processSelectedKeys 处理响应事件</a>\n<ul>\n<li><a href=\"#nioeventloopprocessselectedkeys\">NioEventLoop#processSelectedKeys</a></li>\n<li><a href=\"#nioeventloopprocessselectedkeysoptimized\">NioEventLoop#processSelectedKeysOptimized</a></li>\n<li><a href=\"#nioeventloopprocessselectedkeys-2\">NioEventLoop#processSelectedKeys</a></li>\n<li><a href=\"#channelunsaferead\">channel.unsafe().read()</a>\n<ul>\n<li><a href=\"#nioserversocketchannel%E4%B8%ADunsafe%E5%AE%9E%E4%BE%8Bread\">NioServerSocketChannel中unsafe实例#read</a>\n<ul>\n<li><a href=\"#nioserversocketchanneldoreadmessages\">NioServerSocketChannel#doReadMessages</a></li>\n</ul>\n</li>\n<li><a href=\"#niosocketchannel%E4%B8%ADunsafe%E5%AE%9E%E4%BE%8Bread\">NioSocketChannel中unsafe实例#read</a></li>\n</ul>\n</li>\n<li><a href=\"#piplinefirechannelread\">pipline.fireChannelRead</a>\n<ul>\n<li><a href=\"#nioserversocketchannel-firechannelread\">NioServerSocketChannel #fireChannelRead</a></li>\n<li><a href=\"#niosocketchannel-firechannelread\">NioSocketChannel #fireChannelRead</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","date":"2020-03-17 18:24:13","dateFormat":"2020-03-17"},{"fileName":"netty-serverbootstrap","abstract":"","description":" Netty Server 构建和启动 Netty 线程模型 Server 属性装配 ServerBootStrap bind() initAndRegister() NioServerSocketChannel实例 Serve...","title":"Netty Core ServerBootStrap","tags":[{"index":3,"name":"Source Code Analysis","slug":"C5tzCiKHJ","used":true,"link":"https://wjkcoder.github.io/tag/C5tzCiKHJ/"},{"index":-1,"name":"Netty","slug":"t2_-QPGel","used":true,"link":"https://wjkcoder.github.io/tag/t2_-QPGel/"}],"feature":"https://wjkcoder.github.io/post-images/netty-serverbootstrap.jpeg","link":"https://wjkcoder.github.io/post/netty-serverbootstrap/","stats":{"text":"10 min read","time":552000,"words":1690,"minutes":10},"isTop":true,"toc":"<ul class=\"markdownIt-TOC\">\n<li><a href=\"#netty-server-%E6%9E%84%E5%BB%BA%E5%92%8C%E5%90%AF%E5%8A%A8\">Netty Server 构建和启动</a>\n<ul>\n<li><a href=\"#netty-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B\">Netty 线程模型</a></li>\n<li><a href=\"#server-%E5%B1%9E%E6%80%A7%E8%A3%85%E9%85%8D\">Server 属性装配</a></li>\n</ul>\n</li>\n<li><a href=\"#serverbootstrap-bind\">ServerBootStrap bind()</a>\n<ul>\n<li><a href=\"#initandregister\">initAndRegister()</a>\n<ul>\n<li><a href=\"#nioserversocketchannel-%E5%AE%9E%E4%BE%8B%E5%8C%96\">NioServerSocketChannel 实例化</a></li>\n<li><a href=\"#serverbootstrap%E5%88%9D%E5%A7%8B%E5%8C%96\">ServerBootStrap初始化</a></li>\n<li><a href=\"#serversocketchannel%E6%B3%A8%E5%86%8C%E5%88%B0eventloopgroup\">ServerSocketChannel注册到EventLoopGroup</a></li>\n<li><a href=\"#nioeventloop%E5%BC%82%E6%AD%A5%E6%89%A7%E8%A1%8Cregister0%E6%96%B9%E6%B3%95\">NioEventLoop异步执行register0方法</a></li>\n<li><a href=\"#%E6%89%A7%E8%A1%8Cnio-register%E6%96%B9%E6%B3%95\">执行NIO register方法</a></li>\n</ul>\n</li>\n<li><a href=\"#dobind0\">doBind0</a>\n<ul>\n<li><a href=\"#nioeventloop%E5%BC%82%E6%AD%A5%E6%89%A7%E8%A1%8Cbind\">NioEventLoop异步执行bind</a></li>\n<li><a href=\"#%E6%89%A7%E8%A1%8Cabstractchannel%E7%9A%84bind%E6%96%B9%E6%B3%95\">执行AbstractChannel的bind方法</a></li>\n<li><a href=\"#native-bind0\">Native bind0</a></li>\n<li><a href=\"#native-listen\">Native listen</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","date":"2020-03-16 15:30:53","dateFormat":"2020-03-16"},{"fileName":"netty-nioeventloopgroup","abstract":"","description":" NioEventLoopGroup 实例化 NioEventLoop实例化 Selector 实例化 KQueueSelectorProvider 实例化 KqueueSelectorImpl 实例化 KQueueArrayWrap...","title":"Netty Core NioEventLoopGroup","tags":[{"index":3,"name":"Source Code Analysis","slug":"C5tzCiKHJ","used":true,"link":"https://wjkcoder.github.io/tag/C5tzCiKHJ/"},{"index":-1,"name":"Netty","slug":"t2_-QPGel","used":true,"link":"https://wjkcoder.github.io/tag/t2_-QPGel/"}],"feature":"https://wjkcoder.github.io/post-images/netty-nioeventloopgroup.png","link":"https://wjkcoder.github.io/post/netty-nioeventloopgroup/","stats":{"text":"7 min read","time":360000,"words":1161,"minutes":7},"isTop":true,"toc":"<ul class=\"markdownIt-TOC\">\n<li><a href=\"#nioeventloopgroup-%E5%AE%9E%E4%BE%8B%E5%8C%96\">NioEventLoopGroup 实例化</a>\n<ul>\n<li><a href=\"#nioeventloop%E5%AE%9E%E4%BE%8B%E5%8C%96\">NioEventLoop实例化</a>\n<ul>\n<li><a href=\"#selector-%E5%AE%9E%E4%BE%8B%E5%8C%96\">Selector 实例化</a>\n<ul>\n<li><a href=\"#kqueueselectorprovider-%E5%AE%9E%E4%BE%8B%E5%8C%96\">KQueueSelectorProvider 实例化</a></li>\n<li><a href=\"#kqueueselectorimpl-%E5%AE%9E%E4%BE%8B%E5%8C%96\">KqueueSelectorImpl 实例化</a></li>\n<li><a href=\"#kqueuearraywrapper-%E5%AE%9E%E4%BE%8B%E5%8C%96\">KQueueArrayWrapper 实例化</a>\n<ul>\n<li><a href=\"#1%E8%AE%BF%E9%97%AE%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98\">1.访问直接内存</a></li>\n<li><a href=\"#2%E5%88%9B%E5%BB%BA%E7%B3%BB%E7%BB%9Fkqueue\">2.创建系统kqueue</a></li>\n</ul>\n</li>\n<li><a href=\"#kqueuearraywrapper%E6%B3%A8%E5%86%8C%E4%BA%8B%E4%BB%B6\">KQueueArrayWrapper注册事件</a>\n<ul>\n<li><a href=\"#jni%E4%B8%AD%E7%9A%84register\">JNI中的register</a></li>\n<li><a href=\"#kevent%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0\">kevent系统函数</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","date":"2020-02-04 17:34:20","dateFormat":"2020-02-04"}],"tags":[{"index":-1,"name":"SpringBoot","slug":"JZ_dCeGSA","used":true,"link":"https://wjkcoder.github.io/tag/JZ_dCeGSA/","count":1},{"index":3,"name":"Source Code Analysis","slug":"C5tzCiKHJ","used":true,"link":"https://wjkcoder.github.io/tag/C5tzCiKHJ/","count":5},{"index":-1,"name":"Netty","slug":"t2_-QPGel","used":true,"link":"https://wjkcoder.github.io/tag/t2_-QPGel/","count":4}],"menus":[{"link":"/","name":"Home","openType":"Internal"},{"link":"/archives","name":"Catalog","openType":"Internal"},{"link":"https://wjkcoder.github.io/tags","name":"Groups","openType":"Internal"}],"themeConfig":{"themeName":"Chic","postPageSize":50,"archivesPageSize":50,"siteName":"Jikun WANG","siteDescription":"","footerInfo":"","showFeatureImage":true,"domain":"https://wjkcoder.github.io","postUrlFormat":"SLUG","tagUrlFormat":"SHORT_ID","dateFormat":"YYYY-MM-DD","feedFullText":true,"feedCount":10,"archivesPath":"archives","postPath":"post","tagPath":"tag"},"customConfig":{"Valine":"off","author":"Jikun WANG","baidu":"on","bs":"","cdnSetting":"","copyright":"off","description":"Keep Track and Record ","donate":"off","donate_alipay":"","donate_wechat":"","facebook":"","friends":[],"ga":"","github":"","icpcode":"","icpinfo":"","instagram":"","keywords":"","language":"en","linkedin":"","list":"on","live2d":"off","live2dDebug":"off","love_click_animation":"off","music":"off","musicModel":"fixed","musics":[{"description":"","siteLink":"","siteLogo":"","siteName":""}],"platformLink":"","platformName":"","prismSetting":"https://fastly.jsdelivr.net/gh/ITJoker233/ITJoker233.github.io@latest/CDN/css/Card/prism.min.css","qq":"","rss":"","send":"","sentence":"off","siteFont":"-apple-system,BlinkMacSystemFont,'Helvetica Neue','PingFang SC','Hiragino Sans GB','Droid Sans Fallback','Microsoft YaHei',sans-serif","supportAuthor":"off","tumblr":"","twitter":"","update":"off","valineAppId":"","valineAppKey":"","valineAvatar":"mp","valineHighlight":false,"valinePageSize":10,"valinePlaceholder":"来都来了，不妨评论一下","valineRecordIp":false,"valineVisitor":false,"version":"1.7.6","view":"off","weather":"off","weibo":"","youtube":""},"utils":{"now":1679390455973}}